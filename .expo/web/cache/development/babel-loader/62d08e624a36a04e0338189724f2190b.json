{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport queryString from 'query-string';\nexport default function getPathFromState(state) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n  var configs = createNormalizedConfigs(options);\n  var path = '/';\n  var current = state;\n  var allParams = {};\n  var _loop = function _loop() {\n    var index = typeof current.index === 'number' ? current.index : 0;\n    var route = current.routes[index];\n    var pattern = void 0;\n    var currentParams = _objectSpread({}, route.params);\n    var currentOptions = configs;\n    var nestedRouteNames = [];\n    var hasNext = true;\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n      nestedRouteNames.push(route.name);\n      if (route.params) {\n        (function () {\n          var stringify = (_currentOptions$route = currentOptions[route.name]) === null || _currentOptions$route === void 0 ? void 0 : _currentOptions$route.stringify;\n          currentParams = Object.fromEntries(Object.entries(route.params).map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              key = _ref2[0],\n              value = _ref2[1];\n            return [key, (stringify === null || stringify === void 0 ? void 0 : stringify[key]) ? stringify[key](value) : String(value)];\n          }));\n          if (pattern) {\n            _extends(allParams, currentParams);\n          }\n        })();\n      }\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        var nextRoute = route.state.routes[index];\n        var nestedConfig = currentOptions[route.name].screens;\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          hasNext = false;\n        }\n      }\n    }\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern.split('/').map(function (p) {\n        var name = p.replace(/^:/, '').replace(/\\?$/, '');\n        if (p.startsWith(':')) {\n          var value = allParams[name];\n          if (currentParams) {\n            delete currentParams[name];\n          }\n          if (value === undefined && p.endsWith('?')) {\n            return '';\n          }\n          return encodeURIComponent(value);\n        }\n        return encodeURIComponent(p);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n    if (route.state) {\n      path += '/';\n    } else if (currentParams) {\n      for (var param in currentParams) {\n        if (currentParams[param] === 'undefined') {\n          delete currentParams[param];\n        }\n      }\n      var query = queryString.stringify(currentParams);\n      if (query) {\n        path += \"?\".concat(query);\n      }\n    }\n    current = route.state;\n  };\n  while (current) {\n    var _currentOptions$route;\n    _loop();\n  }\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  return path;\n}\nfunction joinPaths() {\n  var _ref3;\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n  return (_ref3 = []).concat.apply(_ref3, _toConsumableArray(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n}\nfunction createConfigItem(config, parentPattern) {\n  if (typeof config === 'string') {\n    var _pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n    return {\n      pattern: _pattern\n    };\n  }\n  var pattern = config.exact !== true && parentPattern && config.path ? joinPaths(parentPattern, config.path) : config.path;\n  var screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n  return {\n    pattern: pattern === null || pattern === void 0 ? void 0 : pattern.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens: screens\n  };\n}\nfunction createNormalizedConfigs(options, pattern) {\n  return Object.fromEntries(Object.entries(options).map(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      name = _ref5[0],\n      c = _ref5[1];\n    var result = createConfigItem(c, pattern);\n    return [name, result];\n  }));\n}","map":{"version":3,"sources":["getPathFromState.tsx"],"names":["queryString","getPathFromState","state","options","undefined","Error","configs","createNormalizedConfigs","path","current","allParams","index","route","routes","pattern","currentParams","params","currentOptions","nestedRouteNames","hasNext","name","push","stringify","Object","fromEntries","entries","map","key","value","String","screens","length","nextRoute","nestedConfig","join","split","p","replace","startsWith","endsWith","encodeURIComponent","param","query","joinPaths","paths","concat","filter","Boolean","createConfigItem","config","parentPattern","exact","c","result"],"mappings":"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","sourcesContent":["import queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype OptionsItem = {\n  path?: string;\n  exact?: boolean;\n  stringify?: StringifyConfig;\n  screens?: Options;\n};\n\ntype Options = Record<string, string | OptionsItem>;\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * Example:\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       stringify: { author: author => author.toLowerCase() }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state?: State,\n  options: Options = {}\n): string {\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n\n  // Create a normalized configs array which will be easier to use\n  const configs = createNormalizedConfigs(options);\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let currentParams: Record<string, any> = { ...route.params };\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        currentParams = Object.fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = p.replace(/^:/, '').replace(/\\?$/, '');\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            // Remove the used value from the params object since we'll use the rest for query string\n            if (currentParams) {\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete currentParams[name];\n            }\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (currentParams) {\n      for (let param in currentParams) {\n        if (currentParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete currentParams[param];\n        }\n      }\n\n      const query = queryString.stringify(currentParams);\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nfunction joinPaths(...paths: string[]): string {\n  return ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n}\n\nfunction createConfigItem(\n  config: OptionsItem | string,\n  parentPattern?: string\n): ConfigItem {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const pattern =\n    config.exact !== true && parentPattern && config.path\n      ? joinPaths(parentPattern, config.path)\n      : config.path;\n\n  const screens = config.screens\n    ? createNormalizedConfigs(config.screens, pattern)\n    : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n}\n\nfunction createNormalizedConfigs(\n  options: Options,\n  pattern?: string\n): Record<string, ConfigItem> {\n  return Object.fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, pattern);\n\n      return [name, result];\n    })\n  );\n}\n"]},"metadata":{},"sourceType":"module"}