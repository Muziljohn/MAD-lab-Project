{"ast":null,"code":"import * as React from 'react';\nimport { getStateFromPath as getStateFromPathDefault, getPathFromState as getPathFromStateDefault, getActionFromState } from '@react-navigation/core';\nvar getStateLength = function getStateLength(state) {\n  var length = 0;\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n  var focusedState = state.routes[state.index].state;\n  if (focusedState && !focusedState.stale) {\n    length += getStateLength(focusedState) - 1;\n  }\n  return length;\n};\nvar isUsingLinking = false;\nexport default function useLinking(ref, _ref) {\n  var _ref$enabled = _ref.enabled,\n    enabled = _ref$enabled === void 0 ? true : _ref$enabled,\n    config = _ref.config,\n    _ref$getStateFromPath = _ref.getStateFromPath,\n    getStateFromPath = _ref$getStateFromPath === void 0 ? getStateFromPathDefault : _ref$getStateFromPath,\n    _ref$getPathFromState = _ref.getPathFromState,\n    getPathFromState = _ref$getPathFromState === void 0 ? getPathFromStateDefault : _ref$getPathFromState;\n  React.useEffect(function () {\n    if (enabled !== false && isUsingLinking) {\n      throw new Error(['Looks like you have configured linking in multiple places. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Make sure that:', \"- You are not using both 'linking' prop and 'useLinking'\", \"- You don't have 'useLinking' in multiple components\"].join('\\n').trim());\n    } else {\n      isUsingLinking = enabled !== false;\n    }\n    return function () {\n      isUsingLinking = false;\n    };\n  });\n  var enabledRef = React.useRef(enabled);\n  var configRef = React.useRef(config);\n  var getStateFromPathRef = React.useRef(getStateFromPath);\n  var getPathFromStateRef = React.useRef(getPathFromState);\n  React.useEffect(function () {\n    enabledRef.current = enabled;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, enabled, getPathFromState, getStateFromPath]);\n  var getInitialState = React.useCallback(function () {\n    var value;\n    if (enabledRef.current) {\n      var path = location.pathname + location.search;\n      if (path) {\n        value = getStateFromPathRef.current(path, configRef.current);\n      }\n    }\n    var thenable = {\n      then: function then(onfulfilled) {\n        return Promise.resolve(onfulfilled ? onfulfilled(value) : value);\n      },\n      catch: function _catch() {\n        return thenable;\n      }\n    };\n    return thenable;\n  }, []);\n  var previousStateLengthRef = React.useRef(undefined);\n  var previousHistoryIndexRef = React.useRef(0);\n  var pendingIndexChangeRef = React.useRef();\n  var pendingStateUpdateRef = React.useRef(false);\n  var pendingStateMultiUpdateRef = React.useRef(false);\n  var numberOfIndicesAhead = React.useRef(0);\n  React.useEffect(function () {\n    var onPopState = function onPopState() {\n      var _history$state$index, _history$state;\n      var navigation = ref.current;\n      if (!navigation || !enabled) {\n        return;\n      }\n      var previousHistoryIndex = previousHistoryIndexRef.current;\n      var historyIndex = (_history$state$index = (_history$state = history.state) === null || _history$state === void 0 ? void 0 : _history$state.index) !== null && _history$state$index !== void 0 ? _history$state$index : 0;\n      previousHistoryIndexRef.current = historyIndex;\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n      var state = navigation.getRootState();\n      var path = getPathFromStateRef.current(state, configRef.current);\n      var canGoBack = true;\n      var numberOfBacks = 0;\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({\n            index: historyIndex\n          }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks = previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n          pendingStateUpdateRef.current = true;\n          for (var i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current = historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n        var _state = getStateFromPathRef.current(location.pathname + location.search, configRef.current);\n        pendingStateMultiUpdateRef.current = true;\n        if (_state) {\n          var action = getActionFromState(_state);\n          pendingStateUpdateRef.current = true;\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(_state);\n          }\n        }\n      }\n    };\n    window.addEventListener('popstate', onPopState);\n    return function () {\n      return window.removeEventListener('popstate', onPopState);\n    };\n  }, [enabled, ref]);\n  React.useEffect(function () {\n    var _ref$current;\n    if (!enabled) {\n      return;\n    }\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(ref.current.getRootState());\n    }\n    if (ref.current && location.pathname + location.search === '/') {\n      var _history$state$index2, _history$state2;\n      history.replaceState({\n        index: (_history$state$index2 = (_history$state2 = history.state) === null || _history$state2 === void 0 ? void 0 : _history$state2.index) !== null && _history$state$index2 !== void 0 ? _history$state$index2 : 0\n      }, '', getPathFromStateRef.current(ref.current.getRootState(), configRef.current));\n    }\n    var unsubscribe = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.addListener('state', function () {\n      var _previousStateLengthR, _history$state$index3, _history$state3;\n      var navigation = ref.current;\n      if (!navigation) {\n        return;\n      }\n      var state = navigation.getRootState();\n      var path = getPathFromStateRef.current(state, configRef.current);\n      var previousStateLength = (_previousStateLengthR = previousStateLengthRef.current) !== null && _previousStateLengthR !== void 0 ? _previousStateLengthR : 1;\n      var stateLength = getStateLength(state);\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n      previousStateLengthRef.current = stateLength;\n      if (pendingStateUpdateRef.current && location.pathname + location.search === path) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n      var index = (_history$state$index3 = (_history$state3 = history.state) === null || _history$state3 === void 0 ? void 0 : _history$state3.index) !== null && _history$state$index3 !== void 0 ? _history$state$index3 : 0;\n      if (previousStateLength === stateLength) {\n        if (location.pathname + location.search !== path) {\n          history.replaceState({\n            index: index\n          }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        for (var i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({\n            index: index\n          }, '', path);\n        }\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        var delta = Math.min(previousStateLength - stateLength, previousHistoryIndexRef.current - 1);\n        if (delta > 0) {\n          pendingIndexChangeRef.current = index - delta;\n          history.go(-delta);\n        } else {\n          if (location.pathname + location.search !== path) {\n            history.replaceState({\n              index: index\n            }, '', path);\n            previousHistoryIndexRef.current = index;\n          }\n        }\n      }\n    });\n    return unsubscribe;\n  });\n  return {\n    getInitialState: getInitialState\n  };\n}","map":{"version":3,"sources":["useLinking.tsx"],"names":["React","getStateFromPath","getStateFromPathDefault","getPathFromState","getPathFromStateDefault","getActionFromState","getStateLength","state","length","history","index","focusedState","routes","stale","isUsingLinking","useLinking","ref","enabled","config","useEffect","Error","join","trim","enabledRef","useRef","configRef","getStateFromPathRef","getPathFromStateRef","current","getInitialState","useCallback","value","path","location","pathname","search","thenable","then","onfulfilled","Promise","resolve","catch","previousStateLengthRef","undefined","previousHistoryIndexRef","pendingIndexChangeRef","pendingStateUpdateRef","pendingStateMultiUpdateRef","numberOfIndicesAhead","onPopState","navigation","previousHistoryIndex","historyIndex","getRootState","canGoBack","numberOfBacks","replaceState","i","goBack","action","dispatch","resetRoot","window","addEventListener","removeEventListener","unsubscribe","addListener","previousStateLength","stateLength","l","pushState","delta","Math","min","go"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  getStateFromPath as getStateFromPathDefault,\n  getPathFromState as getPathFromStateDefault,\n  NavigationContainerRef,\n  NavigationState,\n  getActionFromState,\n} from '@react-navigation/core';\nimport { LinkingOptions } from './types';\n\ntype ResultState = ReturnType<typeof getStateFromPathDefault>;\n\ntype HistoryState = { index: number };\n\ndeclare const history: {\n  state?: HistoryState;\n  go(delta: number): void;\n  pushState(state: HistoryState, title: string, url: string): void;\n  replaceState(state: HistoryState, title: string, url: string): void;\n};\n\nconst getStateLength = (state: NavigationState) => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState as NavigationState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    enabled = true,\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (enabled !== false && isUsingLinking) {\n      throw new Error(\n        [\n          'Looks like you have configured linking in multiple places. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Make sure that:',\n          \"- You are not using both 'linking' prop and 'useLinking'\",\n          \"- You don't have 'useLinking' in multiple components\",\n        ]\n          .join('\\n')\n          .trim()\n      );\n    } else {\n      isUsingLinking = enabled !== false;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const enabledRef = React.useRef(enabled);\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n\n  React.useEffect(() => {\n    enabledRef.current = enabled;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, enabled, getPathFromState, getStateFromPath]);\n\n  const getInitialState = React.useCallback(() => {\n    let value: ResultState | undefined;\n\n    if (enabledRef.current) {\n      const path = location.pathname + location.search;\n\n      if (path) {\n        value = getStateFromPathRef.current(path, configRef.current);\n      }\n    }\n\n    // Make it a thenable to keep consistent with the native impl\n    const thenable = {\n      then(onfulfilled?: (state: ResultState | undefined) => void) {\n        return Promise.resolve(onfulfilled ? onfulfilled(value) : value);\n      },\n      catch() {\n        return thenable;\n      },\n    };\n\n    return thenable as PromiseLike<ResultState | undefined>;\n  }, []);\n\n  const previousStateLengthRef = React.useRef<number | undefined>(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n\n  const pendingIndexChangeRef = React.useRef<number | undefined>();\n  const pendingStateUpdateRef = React.useRef<boolean>(false);\n  const pendingStateMultiUpdateRef = React.useRef<boolean>(false);\n\n  // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n  const numberOfIndicesAhead = React.useRef(0);\n\n  React.useEffect(() => {\n    const onPopState = () => {\n      const navigation = ref.current;\n\n      if (!navigation || !enabled) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = history.state?.index ?? 0;\n\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({ index: historyIndex }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks =\n          previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current =\n            historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(\n          location.pathname + location.search,\n          configRef.current\n        );\n\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          pendingStateUpdateRef.current = true;\n\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(state);\n          }\n        }\n      }\n    };\n\n    window.addEventListener('popstate', onPopState);\n\n    return () => window.removeEventListener('popstate', onPopState);\n  }, [enabled, ref]);\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(\n        ref.current.getRootState()\n      );\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      history.replaceState(\n        { index: history.state?.index ?? 0 },\n        '',\n        getPathFromStateRef.current(\n          ref.current.getRootState(),\n          configRef.current\n        )\n      );\n    }\n\n    const unsubscribe = ref.current?.addListener('state', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      const previousStateLength = previousStateLengthRef.current ?? 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (\n        pendingStateUpdateRef.current &&\n        location.pathname + location.search === path\n      ) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = history.state?.index ?? 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new entries were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({ index }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new entries were added, pushState until we have same length\n        // This won't be accurate if multiple entries were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({ index }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = Math.min(\n          previousStateLength - stateLength,\n          // We need to keep at least one item in the history\n          // Otherwise we'll exit the page\n          previousHistoryIndexRef.current - 1\n        );\n\n        if (delta > 0) {\n          // We need to set this to ignore the `popstate` event\n          pendingIndexChangeRef.current = index - delta;\n\n          // If new entries were removed, go back so that we have same length\n          history.go(-delta);\n        } else {\n          // We're not going back in history, but the navigation state changed\n          // The URL probably also changed, so we need to re-sync the URL\n          if (location.pathname + location.search !== path) {\n            history.replaceState({ index }, '', path);\n            previousHistoryIndexRef.current = index;\n          }\n        }\n      }\n    });\n\n    return unsubscribe;\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}