{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { EventEmitter } from '@unimodules/core';\nvar GeocoderError = function (_Error) {\n  _inherits(GeocoderError, _Error);\n  var _super = _createSuper(GeocoderError);\n  function GeocoderError() {\n    var _this;\n    _classCallCheck(this, GeocoderError);\n    _this = _super.call(this, 'Geocoder service is not available for this device.');\n    _this.code = 'E_NO_GEOCODER';\n    return _this;\n  }\n  return GeocoderError;\n}(_wrapNativeSuper(Error));\nvar emitter = new EventEmitter({});\nfunction positionToJSON(position) {\n  if (!position) return null;\n  var _position$coords = position.coords,\n    coords = _position$coords === void 0 ? {} : _position$coords,\n    timestamp = position.timestamp;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed\n    },\n    timestamp: timestamp\n  };\n}\nexport default {\n  get name() {\n    return 'ExpoLocation';\n  },\n  getProviderStatusAsync: function getProviderStatusAsync() {\n    return _regeneratorRuntime.async(function getProviderStatusAsync$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", {\n              locationServicesEnabled: 'geolocation' in navigator\n            });\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  getCurrentPositionAsync: function getCurrentPositionAsync(options) {\n    return _regeneratorRuntime.async(function getCurrentPositionAsync$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n              return navigator.geolocation.getCurrentPosition(function (position) {\n                return resolve(positionToJSON(position));\n              }, reject, options);\n            }));\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  removeWatchAsync: function removeWatchAsync(watchId) {\n    return _regeneratorRuntime.async(function removeWatchAsync$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            navigator.geolocation.clearWatch(watchId);\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  watchDeviceHeading: function watchDeviceHeading(headingId) {\n    return _regeneratorRuntime.async(function watchDeviceHeading$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            console.warn('Location.watchDeviceHeading: is not supported on web');\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  hasServicesEnabledAsync: function hasServicesEnabledAsync() {\n    return _regeneratorRuntime.async(function hasServicesEnabledAsync$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            return _context5.abrupt(\"return\", 'geolocation' in navigator);\n          case 1:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  geocodeAsync: function geocodeAsync() {\n    return _regeneratorRuntime.async(function geocodeAsync$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            throw new GeocoderError();\n          case 1:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  reverseGeocodeAsync: function reverseGeocodeAsync() {\n    return _regeneratorRuntime.async(function reverseGeocodeAsync$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            throw new GeocoderError();\n          case 1:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  watchPositionImplAsync: function watchPositionImplAsync(watchId, options) {\n    return _regeneratorRuntime.async(function watchPositionImplAsync$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", new Promise(function (resolve) {\n              watchId = global.navigator.geolocation.watchPosition(function (location) {\n                emitter.emit('Expo.locationChanged', {\n                  watchId: watchId,\n                  location: positionToJSON(location)\n                });\n              }, null, options);\n              resolve(watchId);\n            }));\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  requestPermissionsAsync: function requestPermissionsAsync() {\n    return _regeneratorRuntime.async(function requestPermissionsAsync$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            return _context9.abrupt(\"return\", new Promise(function (resolve) {\n              navigator.geolocation.getCurrentPosition(function () {\n                return resolve({\n                  status: 'granted'\n                });\n              }, function (_ref) {\n                var code = _ref.code;\n                if (code === 1) {\n                  resolve({\n                    status: 'denied'\n                  });\n                } else {\n                  resolve({\n                    status: 'undetermined'\n                  });\n                }\n              });\n            }));\n          case 1:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};","map":{"version":3,"sources":["../src/ExpoLocation.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from '@unimodules/core';\n\ninterface Coordinates {\n  latitude: number;\n  longitude: number;\n  altitude?: number;\n  accuracy?: number;\n  altitudeAccuracy?: number;\n  heading?: number;\n  speed?: number;\n}\n\ninterface Position {\n  coords: Coordinates;\n  timestamp: number;\n}\n\ninterface PermissionResult {\n  status: string;\n}\n\nclass GeocoderError extends Error {\n  code: string;\n\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n}\n\nconst emitter = new EventEmitter({} as any);\n\nfunction positionToJSON(position: any): Position | null {\n  if (!position) return null;\n\n  const { coords = {}, timestamp } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed,\n    },\n    timestamp,\n  };\n}\n\nexport default {\n  get name(): string {\n    return 'ExpoLocation';\n  },\n  async getProviderStatusAsync(): Promise<{ locationServicesEnabled: boolean }> {\n    return {\n      locationServicesEnabled: 'geolocation' in navigator,\n    };\n  },\n  async getCurrentPositionAsync(options: object): Promise<Position | null> {\n    return new Promise<Position | null>((resolve, reject) =>\n      navigator.geolocation.getCurrentPosition(\n        position => resolve(positionToJSON(position)),\n        reject,\n        options\n      )\n    );\n  },\n  async removeWatchAsync(watchId): Promise<void> {\n    navigator.geolocation.clearWatch(watchId);\n  },\n  async watchDeviceHeading(headingId): Promise<void> {\n    console.warn('Location.watchDeviceHeading: is not supported on web');\n  },\n  async hasServicesEnabledAsync(): Promise<boolean> {\n    return 'geolocation' in navigator;\n  },\n  async geocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async reverseGeocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async watchPositionImplAsync(watchId: string, options: object): Promise<string> {\n    return new Promise<string>(resolve => {\n      // @ts-ignore\n      watchId = global.navigator.geolocation.watchPosition(\n        location => {\n          emitter.emit('Expo.locationChanged', { watchId, location: positionToJSON(location) });\n        },\n        null,\n        options\n      );\n      resolve(watchId);\n    });\n  },\n  async requestPermissionsAsync(): Promise<PermissionResult> {\n    return new Promise<PermissionResult>(resolve => {\n      navigator.geolocation.getCurrentPosition(\n        () => resolve({ status: 'granted' }),\n        ({ code }) => {\n          if (code === 1 /* PERMISSION_DENIED */) {\n            resolve({ status: 'denied' });\n          } else {\n            resolve({ status: 'undetermined' });\n          }\n        }\n      );\n    });\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}