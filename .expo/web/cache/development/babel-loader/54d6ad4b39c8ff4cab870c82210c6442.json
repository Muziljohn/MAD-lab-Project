{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nimport { EventEmitter, Platform, CodedError } from '@unimodules/core';\nimport invariant from 'invariant';\nimport { PermissionStatus } from 'unimodules-permissions-interface';\nimport ExpoLocation from \"./ExpoLocation\";\nvar LocationEventEmitter = new EventEmitter(ExpoLocation);\nexport { PermissionStatus };\nvar LocationAccuracy;\n(function (LocationAccuracy) {\n  LocationAccuracy[LocationAccuracy[\"Lowest\"] = 1] = \"Lowest\";\n  LocationAccuracy[LocationAccuracy[\"Low\"] = 2] = \"Low\";\n  LocationAccuracy[LocationAccuracy[\"Balanced\"] = 3] = \"Balanced\";\n  LocationAccuracy[LocationAccuracy[\"High\"] = 4] = \"High\";\n  LocationAccuracy[LocationAccuracy[\"Highest\"] = 5] = \"Highest\";\n  LocationAccuracy[LocationAccuracy[\"BestForNavigation\"] = 6] = \"BestForNavigation\";\n})(LocationAccuracy || (LocationAccuracy = {}));\nvar LocationActivityType;\n(function (LocationActivityType) {\n  LocationActivityType[LocationActivityType[\"Other\"] = 1] = \"Other\";\n  LocationActivityType[LocationActivityType[\"AutomotiveNavigation\"] = 2] = \"AutomotiveNavigation\";\n  LocationActivityType[LocationActivityType[\"Fitness\"] = 3] = \"Fitness\";\n  LocationActivityType[LocationActivityType[\"OtherNavigation\"] = 4] = \"OtherNavigation\";\n  LocationActivityType[LocationActivityType[\"Airborne\"] = 5] = \"Airborne\";\n})(LocationActivityType || (LocationActivityType = {}));\nexport { LocationAccuracy as Accuracy, LocationActivityType as ActivityType };\nexport var GeofencingEventType;\n(function (GeofencingEventType) {\n  GeofencingEventType[GeofencingEventType[\"Enter\"] = 1] = \"Enter\";\n  GeofencingEventType[GeofencingEventType[\"Exit\"] = 2] = \"Exit\";\n})(GeofencingEventType || (GeofencingEventType = {}));\nexport var GeofencingRegionState;\n(function (GeofencingRegionState) {\n  GeofencingRegionState[GeofencingRegionState[\"Unknown\"] = 0] = \"Unknown\";\n  GeofencingRegionState[GeofencingRegionState[\"Inside\"] = 1] = \"Inside\";\n  GeofencingRegionState[GeofencingRegionState[\"Outside\"] = 2] = \"Outside\";\n})(GeofencingRegionState || (GeofencingRegionState = {}));\nvar nextWatchId = 0;\nvar headingId;\nfunction _getNextWatchId() {\n  nextWatchId++;\n  return nextWatchId;\n}\nfunction _getCurrentWatchId() {\n  return nextWatchId;\n}\nvar watchCallbacks = {};\nvar deviceEventSubscription;\nvar headingEventSub;\nvar googleApiKey;\nvar googleApiUrl = 'https://maps.googleapis.com/maps/api/geocode/json';\nexport function getProviderStatusAsync() {\n  return _regeneratorRuntime.async(function getProviderStatusAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", ExpoLocation.getProviderStatusAsync());\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function enableNetworkProviderAsync() {\n  return _regeneratorRuntime.async(function enableNetworkProviderAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(Platform.OS === 'android')) {\n            _context2.next = 2;\n            break;\n          }\n          return _context2.abrupt(\"return\", ExpoLocation.enableNetworkProviderAsync());\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getCurrentPositionAsync() {\n  var options,\n    _args3 = arguments;\n  return _regeneratorRuntime.async(function getCurrentPositionAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n          return _context3.abrupt(\"return\", ExpoLocation.getCurrentPositionAsync(options));\n        case 2:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getLastKnownPositionAsync() {\n  return _regeneratorRuntime.async(function getLastKnownPositionAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.abrupt(\"return\", ExpoLocation.getLastKnownPositionAsync());\n        case 1:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getHeadingAsync() {\n  return _regeneratorRuntime.async(function getHeadingAsync$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          return _context6.abrupt(\"return\", new Promise(function _callee(resolve, reject) {\n            var tries, headingSub, done, subscription, _tries;\n            return _regeneratorRuntime.async(function _callee$(_context5) {\n              while (1) {\n                switch (_context5.prev = _context5.next) {\n                  case 0:\n                    _context5.prev = 0;\n                    if (!headingEventSub) {\n                      _context5.next = 6;\n                      break;\n                    }\n                    tries = 0;\n                    headingSub = LocationEventEmitter.addListener('Expo.headingChanged', function (_ref) {\n                      var heading = _ref.heading;\n                      if (heading.accuracy > 1 || tries > 5) {\n                        resolve(heading);\n                        LocationEventEmitter.removeSubscription(headingSub);\n                      } else {\n                        tries += 1;\n                      }\n                    });\n                    _context5.next = 12;\n                    break;\n                  case 6:\n                    done = false;\n                    _tries = 0;\n                    _context5.next = 10;\n                    return _regeneratorRuntime.awrap(watchHeadingAsync(function (heading) {\n                      if (!done) {\n                        if (heading.accuracy > 1 || _tries > 5) {\n                          subscription.remove();\n                          resolve(heading);\n                          done = true;\n                        } else {\n                          _tries += 1;\n                        }\n                      } else {\n                        subscription.remove();\n                      }\n                    }));\n                  case 10:\n                    subscription = _context5.sent;\n                    if (done) {\n                      subscription.remove();\n                    }\n                  case 12:\n                    _context5.next = 17;\n                    break;\n                  case 14:\n                    _context5.prev = 14;\n                    _context5.t0 = _context5[\"catch\"](0);\n                    reject(_context5.t0);\n                  case 17:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }\n            }, null, null, [[0, 14]], Promise);\n          }));\n        case 1:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function watchHeadingAsync(callback) {\n  return _regeneratorRuntime.async(function watchHeadingAsync$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          if (headingEventSub) {\n            _removeHeadingWatcher(headingId);\n          }\n          headingEventSub = LocationEventEmitter.addListener('Expo.headingChanged', function (_ref2) {\n            var watchId = _ref2.watchId,\n              heading = _ref2.heading;\n            var callback = watchCallbacks[watchId];\n            if (callback) {\n              callback(heading);\n            } else {\n              ExpoLocation.removeWatchAsync(watchId);\n            }\n          });\n          headingId = _getNextWatchId();\n          watchCallbacks[headingId] = callback;\n          _context7.next = 6;\n          return _regeneratorRuntime.awrap(ExpoLocation.watchDeviceHeading(headingId));\n        case 6:\n          return _context7.abrupt(\"return\", {\n            remove: function remove() {\n              _removeHeadingWatcher(headingId);\n            }\n          });\n        case 7:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _removeHeadingWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n  delete watchCallbacks[watchId];\n  ExpoLocation.removeWatchAsync(watchId);\n  if (headingEventSub) {\n    LocationEventEmitter.removeSubscription(headingEventSub);\n    headingEventSub = null;\n  }\n}\nfunction _maybeInitializeEmitterSubscription() {\n  if (!deviceEventSubscription) {\n    deviceEventSubscription = LocationEventEmitter.addListener('Expo.locationChanged', function (_ref3) {\n      var watchId = _ref3.watchId,\n        location = _ref3.location;\n      var callback = watchCallbacks[watchId];\n      if (callback) {\n        callback(location);\n      } else {\n        ExpoLocation.removeWatchAsync(watchId);\n      }\n    });\n  }\n}\nexport function geocodeAsync(address) {\n  return _regeneratorRuntime.async(function geocodeAsync$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          return _context8.abrupt(\"return\", ExpoLocation.geocodeAsync(address).catch(function (error) {\n            var platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n            if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n              if (!googleApiKey) {\n                throw new CodedError(error.code, error.message + \" Please set a Google API Key to use geocoding.\");\n              }\n              return _googleGeocodeAsync(address);\n            }\n            throw error;\n          }));\n        case 1:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function reverseGeocodeAsync(location) {\n  return _regeneratorRuntime.async(function reverseGeocodeAsync$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          if (!(typeof location.latitude !== 'number' || typeof location.longitude !== 'number')) {\n            _context9.next = 2;\n            break;\n          }\n          throw new TypeError('Location should be an object with number properties `latitude` and `longitude`.');\n        case 2:\n          return _context9.abrupt(\"return\", ExpoLocation.reverseGeocodeAsync(location).catch(function (error) {\n            var platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n            if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n              if (!googleApiKey) {\n                throw new CodedError(error.code, error.message + \" Please set a Google API Key to use geocoding.\");\n              }\n              return _googleReverseGeocodeAsync(location);\n            }\n            throw error;\n          }));\n        case 3:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function setApiKey(apiKey) {\n  googleApiKey = apiKey;\n}\nfunction _googleGeocodeAsync(address) {\n  var result, resultObject;\n  return _regeneratorRuntime.async(function _googleGeocodeAsync$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          _context10.next = 2;\n          return _regeneratorRuntime.awrap(fetch(googleApiUrl + \"?key=\" + googleApiKey + \"&address=\" + encodeURI(address)));\n        case 2:\n          result = _context10.sent;\n          _context10.next = 5;\n          return _regeneratorRuntime.awrap(result.json());\n        case 5:\n          resultObject = _context10.sent;\n          if (!(resultObject.status === 'ZERO_RESULTS')) {\n            _context10.next = 8;\n            break;\n          }\n          return _context10.abrupt(\"return\", []);\n        case 8:\n          assertGeocodeResults(resultObject);\n          return _context10.abrupt(\"return\", resultObject.results.map(function (result) {\n            var location = result.geometry.location;\n            return {\n              latitude: location.lat,\n              longitude: location.lng\n            };\n          }));\n        case 10:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _googleReverseGeocodeAsync(options) {\n  var result, resultObject;\n  return _regeneratorRuntime.async(function _googleReverseGeocodeAsync$(_context11) {\n    while (1) {\n      switch (_context11.prev = _context11.next) {\n        case 0:\n          _context11.next = 2;\n          return _regeneratorRuntime.awrap(fetch(googleApiUrl + \"?key=\" + googleApiKey + \"&latlng=\" + options.latitude + \",\" + options.longitude));\n        case 2:\n          result = _context11.sent;\n          _context11.next = 5;\n          return _regeneratorRuntime.awrap(result.json());\n        case 5:\n          resultObject = _context11.sent;\n          if (!(resultObject.status === 'ZERO_RESULTS')) {\n            _context11.next = 8;\n            break;\n          }\n          return _context11.abrupt(\"return\", []);\n        case 8:\n          assertGeocodeResults(resultObject);\n          return _context11.abrupt(\"return\", resultObject.results.map(function (result) {\n            var address = {};\n            result.address_components.forEach(function (component) {\n              if (component.types.includes('locality')) {\n                address.city = component.long_name;\n              } else if (component.types.includes('street_address')) {\n                address.street = component.long_name;\n              } else if (component.types.includes('administrative_area_level_1')) {\n                address.region = component.long_name;\n              } else if (component.types.includes('country')) {\n                address.country = component.long_name;\n              } else if (component.types.includes('postal_code')) {\n                address.postalCode = component.long_name;\n              } else if (component.types.includes('point_of_interest')) {\n                address.name = component.long_name;\n              }\n            });\n            return address;\n          }));\n        case 10:\n        case \"end\":\n          return _context11.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction assertGeocodeResults(resultObject) {\n  var status = resultObject.status,\n    error_message = resultObject.error_message;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(status, 'the request could not be processed due to a server error. The request may succeed if you try again.');\n    }\n    throw new CodedError(status, \"An error occurred during geocoding.\");\n  }\n}\nfunction watchPosition(success, error, options) {\n  _maybeInitializeEmitterSubscription();\n  var watchId = _getNextWatchId();\n  watchCallbacks[watchId] = success;\n  ExpoLocation.watchPositionImplAsync(watchId, options).catch(function (err) {\n    _removeWatcher(watchId);\n    error({\n      watchId: watchId,\n      message: err.message,\n      code: err.code\n    });\n  });\n  return watchId;\n}\nexport function watchPositionAsync(options, callback) {\n  var watchId;\n  return _regeneratorRuntime.async(function watchPositionAsync$(_context12) {\n    while (1) {\n      switch (_context12.prev = _context12.next) {\n        case 0:\n          _maybeInitializeEmitterSubscription();\n          watchId = _getNextWatchId();\n          watchCallbacks[watchId] = callback;\n          _context12.next = 5;\n          return _regeneratorRuntime.awrap(ExpoLocation.watchPositionImplAsync(watchId, options));\n        case 5:\n          return _context12.abrupt(\"return\", {\n            remove: function remove() {\n              _removeWatcher(watchId);\n            }\n          });\n        case 6:\n        case \"end\":\n          return _context12.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction clearWatch(watchId) {\n  _removeWatcher(watchId);\n}\nfunction _removeWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n  ExpoLocation.removeWatchAsync(watchId);\n  delete watchCallbacks[watchId];\n  if (Object.keys(watchCallbacks).length === 0 && deviceEventSubscription) {\n    LocationEventEmitter.removeSubscription(deviceEventSubscription);\n    deviceEventSubscription = null;\n  }\n}\nfunction getCurrentPosition(success) {\n  var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  invariant(typeof success === 'function', 'Must provide a valid success callback.');\n  invariant(typeof options === 'object', 'options must be an object.');\n  _getCurrentPositionAsyncWrapper(success, error, options);\n}\nfunction _getCurrentPositionAsyncWrapper(success, error, options) {\n  var result;\n  return _regeneratorRuntime.async(function _getCurrentPositionAsyncWrapper$(_context13) {\n    while (1) {\n      switch (_context13.prev = _context13.next) {\n        case 0:\n          _context13.prev = 0;\n          _context13.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.requestPermissionsAsync());\n        case 3:\n          _context13.next = 5;\n          return _regeneratorRuntime.awrap(getCurrentPositionAsync(options));\n        case 5:\n          result = _context13.sent;\n          success(result);\n          _context13.next = 12;\n          break;\n        case 9:\n          _context13.prev = 9;\n          _context13.t0 = _context13[\"catch\"](0);\n          error(_context13.t0);\n        case 12:\n        case \"end\":\n          return _context13.stop();\n      }\n    }\n  }, null, null, [[0, 9]], Promise);\n}\nexport function getPermissionsAsync() {\n  return _regeneratorRuntime.async(function getPermissionsAsync$(_context14) {\n    while (1) {\n      switch (_context14.prev = _context14.next) {\n        case 0:\n          _context14.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.getPermissionsAsync());\n        case 2:\n          return _context14.abrupt(\"return\", _context14.sent);\n        case 3:\n        case \"end\":\n          return _context14.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function requestPermissionsAsync() {\n  return _regeneratorRuntime.async(function requestPermissionsAsync$(_context15) {\n    while (1) {\n      switch (_context15.prev = _context15.next) {\n        case 0:\n          _context15.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.requestPermissionsAsync());\n        case 2:\n          return _context15.abrupt(\"return\", _context15.sent);\n        case 3:\n        case \"end\":\n          return _context15.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasServicesEnabledAsync() {\n  return _regeneratorRuntime.async(function hasServicesEnabledAsync$(_context16) {\n    while (1) {\n      switch (_context16.prev = _context16.next) {\n        case 0:\n          _context16.next = 2;\n          return _regeneratorRuntime.awrap(ExpoLocation.hasServicesEnabledAsync());\n        case 2:\n          return _context16.abrupt(\"return\", _context16.sent);\n        case 3:\n        case \"end\":\n          return _context16.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _validateTaskName(taskName) {\n  invariant(taskName && typeof taskName === 'string', '`taskName` must be a non-empty string.');\n}\nexport function isBackgroundLocationAvailableAsync() {\n  var providerStatus;\n  return _regeneratorRuntime.async(function isBackgroundLocationAvailableAsync$(_context17) {\n    while (1) {\n      switch (_context17.prev = _context17.next) {\n        case 0:\n          _context17.next = 2;\n          return _regeneratorRuntime.awrap(getProviderStatusAsync());\n        case 2:\n          providerStatus = _context17.sent;\n          return _context17.abrupt(\"return\", providerStatus.backgroundModeEnabled);\n        case 4:\n        case \"end\":\n          return _context17.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function startLocationUpdatesAsync(taskName) {\n  var options,\n    _args18 = arguments;\n  return _regeneratorRuntime.async(function startLocationUpdatesAsync$(_context18) {\n    while (1) {\n      switch (_context18.prev = _context18.next) {\n        case 0:\n          options = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : {\n            accuracy: LocationAccuracy.Balanced\n          };\n          _validateTaskName(taskName);\n          _context18.next = 4;\n          return _regeneratorRuntime.awrap(ExpoLocation.startLocationUpdatesAsync(taskName, options));\n        case 4:\n        case \"end\":\n          return _context18.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function stopLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime.async(function stopLocationUpdatesAsync$(_context19) {\n    while (1) {\n      switch (_context19.prev = _context19.next) {\n        case 0:\n          _validateTaskName(taskName);\n          _context19.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.stopLocationUpdatesAsync(taskName));\n        case 3:\n        case \"end\":\n          return _context19.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasStartedLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime.async(function hasStartedLocationUpdatesAsync$(_context20) {\n    while (1) {\n      switch (_context20.prev = _context20.next) {\n        case 0:\n          _validateTaskName(taskName);\n          return _context20.abrupt(\"return\", ExpoLocation.hasStartedLocationUpdatesAsync(taskName));\n        case 2:\n        case \"end\":\n          return _context20.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _validateRegions(regions) {\n  if (!regions || regions.length === 0) {\n    throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');\n  }\n  for (var _iterator = _createForOfIteratorHelperLoose(regions), _step; !(_step = _iterator()).done;) {\n    var region = _step.value;\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(\"Region's latitude must be a number. Got '\" + region.latitude + \"' instead.\");\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\"Region's longitude must be a number. Got '\" + region.longitude + \"' instead.\");\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(\"Region's radius must be a number. Got '\" + region.radius + \"' instead.\");\n    }\n  }\n}\nexport function startGeofencingAsync(taskName) {\n  var regions,\n    _args21 = arguments;\n  return _regeneratorRuntime.async(function startGeofencingAsync$(_context21) {\n    while (1) {\n      switch (_context21.prev = _context21.next) {\n        case 0:\n          regions = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : [];\n          _validateTaskName(taskName);\n          _validateRegions(regions);\n          _context21.next = 5;\n          return _regeneratorRuntime.awrap(ExpoLocation.startGeofencingAsync(taskName, {\n            regions: regions\n          }));\n        case 5:\n        case \"end\":\n          return _context21.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function stopGeofencingAsync(taskName) {\n  return _regeneratorRuntime.async(function stopGeofencingAsync$(_context22) {\n    while (1) {\n      switch (_context22.prev = _context22.next) {\n        case 0:\n          _validateTaskName(taskName);\n          _context22.next = 3;\n          return _regeneratorRuntime.awrap(ExpoLocation.stopGeofencingAsync(taskName));\n        case 3:\n        case \"end\":\n          return _context22.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasStartedGeofencingAsync(taskName) {\n  return _regeneratorRuntime.async(function hasStartedGeofencingAsync$(_context23) {\n    while (1) {\n      switch (_context23.prev = _context23.next) {\n        case 0:\n          _validateTaskName(taskName);\n          return _context23.abrupt(\"return\", ExpoLocation.hasStartedGeofencingAsync(taskName));\n        case 2:\n        case \"end\":\n          return _context23.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function installWebGeolocationPolyfill() {\n  if (Platform.OS !== 'web') {\n    window.navigator.geolocation = {\n      getCurrentPosition: getCurrentPosition,\n      watchPosition: watchPosition,\n      clearWatch: clearWatch,\n      stopObserving: function stopObserving() {}\n    };\n  }\n}\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };","map":{"version":3,"sources":["../src/Location.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter, Platform, CodedError } from '@unimodules/core';\nimport invariant from 'invariant';\nimport {\n  PermissionResponse as UMPermissionResponse,\n  PermissionStatus,\n} from 'unimodules-permissions-interface';\n\nimport ExpoLocation from './ExpoLocation';\n\nconst LocationEventEmitter = new EventEmitter(ExpoLocation);\n\nexport interface ProviderStatus {\n  locationServicesEnabled: boolean;\n  backgroundModeEnabled: boolean;\n  gpsAvailable?: boolean;\n  networkAvailable?: boolean;\n  passiveAvailable?: boolean;\n}\n\nexport interface LocationOptions {\n  accuracy?: LocationAccuracy;\n  maximumAge?: number;\n  enableHighAccuracy?: boolean;\n  timeInterval?: number;\n  distanceInterval?: number;\n  timeout?: number;\n  mayShowUserSettingsDialog?: boolean;\n}\n\nexport interface LocationData {\n  coords: {\n    latitude: number;\n    longitude: number;\n    altitude: number;\n    accuracy: number;\n    heading: number;\n    speed: number;\n  };\n  timestamp: number;\n}\n\nexport interface HeadingData {\n  trueHeading: number;\n  magHeading: number;\n  accuracy: number;\n}\n\nexport interface GeocodedLocation {\n  latitude: number;\n  longitude: number;\n  altitude?: number;\n  accuracy?: number;\n}\n\nexport interface Address {\n  city: string;\n  street: string;\n  region: string;\n  country: string;\n  postalCode: string;\n  name: string;\n}\n\nexport { PermissionStatus };\n\nexport type PermissionDetailsLocationIOS = {\n  scope: 'whenInUse' | 'always';\n};\n\nexport type PermissionDetailsLocationAndroid = {\n  scope: 'fine' | 'coarse' | 'none';\n};\n\nexport interface PermissionResponse extends UMPermissionResponse {\n  ios?: PermissionDetailsLocationIOS;\n  android?: PermissionDetailsLocationAndroid;\n}\n\nexport interface LocationTaskOptions {\n  accuracy?: LocationAccuracy;\n  timeInterval?: number; // Android only\n  distanceInterval?: number;\n  showsBackgroundLocationIndicator?: boolean; // iOS only\n  deferredUpdatesDistance?: number;\n  deferredUpdatesTimeout?: number;\n  deferredUpdatesInterval?: number;\n\n  // iOS only\n  activityType?: LocationActivityType;\n  pausesUpdatesAutomatically?: boolean;\n\n  foregroundService?: {\n    notificationTitle: string;\n    notificationBody: string;\n    notificationColor?: string;\n  };\n}\n\nexport interface LocationRegion {\n  identifier?: string;\n  latitude: number;\n  longitude: number;\n  radius: number;\n  notifyOnEnter?: boolean;\n  notifyOnExit?: boolean;\n}\n\ntype Subscription = {\n  remove: () => void;\n};\nexport type LocationCallback = (data: LocationData) => any;\nexport type LocationHeadingCallback = (data: HeadingData) => any;\n\nenum LocationAccuracy {\n  Lowest = 1,\n  Low = 2,\n  Balanced = 3,\n  High = 4,\n  Highest = 5,\n  BestForNavigation = 6,\n}\n\nenum LocationActivityType {\n  Other = 1,\n  AutomotiveNavigation = 2,\n  Fitness = 3,\n  OtherNavigation = 4,\n  Airborne = 5,\n}\n\nexport { LocationAccuracy as Accuracy, LocationActivityType as ActivityType };\n\nexport enum GeofencingEventType {\n  Enter = 1,\n  Exit = 2,\n}\n\nexport enum GeofencingRegionState {\n  Unknown = 0,\n  Inside = 1,\n  Outside = 2,\n}\n\nlet nextWatchId = 0;\nlet headingId;\nfunction _getNextWatchId() {\n  nextWatchId++;\n  return nextWatchId;\n}\nfunction _getCurrentWatchId() {\n  return nextWatchId;\n}\n\nlet watchCallbacks: {\n  [watchId: number]: LocationCallback | LocationHeadingCallback;\n} = {};\n\nlet deviceEventSubscription: Subscription | null;\nlet headingEventSub: Subscription | null;\nlet googleApiKey;\nconst googleApiUrl = 'https://maps.googleapis.com/maps/api/geocode/json';\n\nexport async function getProviderStatusAsync(): Promise<ProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationData> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\nexport async function getLastKnownPositionAsync(): Promise<LocationData> {\n  return ExpoLocation.getLastKnownPositionAsync();\n}\n\n// Start Compass Module\n\n// To simplify, we will call watchHeadingAsync and wait for one update To ensure accuracy, we wait\n// for a couple of watch updates if the data has low accuracy\nexport async function getHeadingAsync(): Promise<HeadingData> {\n  return new Promise<HeadingData>(async (resolve, reject) => {\n    try {\n      // If there is already a compass active (would be a watch)\n      if (headingEventSub) {\n        let tries = 0;\n        const headingSub = LocationEventEmitter.addListener(\n          'Expo.headingChanged',\n          ({ heading }: { heading: HeadingData }) => {\n            if (heading.accuracy > 1 || tries > 5) {\n              resolve(heading);\n              LocationEventEmitter.removeSubscription(headingSub);\n            } else {\n              tries += 1;\n            }\n          }\n        );\n      } else {\n        let done = false;\n        let subscription;\n        let tries = 0;\n        subscription = await watchHeadingAsync((heading: HeadingData) => {\n          if (!done) {\n            if (heading.accuracy > 1 || tries > 5) {\n              subscription.remove();\n              resolve(heading);\n              done = true;\n            } else {\n              tries += 1;\n            }\n          } else {\n            subscription.remove();\n          }\n        });\n\n        if (done) {\n          subscription.remove();\n        }\n      }\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback\n): Promise<{ remove: () => void }> {\n  // Check if there is already a compass event watch.\n  if (headingEventSub) {\n    _removeHeadingWatcher(headingId);\n  }\n\n  headingEventSub = LocationEventEmitter.addListener(\n    'Expo.headingChanged',\n    ({ watchId, heading }: { watchId: string; heading: HeadingData }) => {\n      const callback = watchCallbacks[watchId];\n      if (callback) {\n        callback(heading);\n      } else {\n        ExpoLocation.removeWatchAsync(watchId);\n      }\n    }\n  );\n\n  headingId = _getNextWatchId();\n  watchCallbacks[headingId] = callback;\n  await ExpoLocation.watchDeviceHeading(headingId);\n  return {\n    remove() {\n      _removeHeadingWatcher(headingId);\n    },\n  };\n}\n\n// Removes the compass listener and sub from JS and Native\nfunction _removeHeadingWatcher(watchId) {\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n  delete watchCallbacks[watchId];\n  ExpoLocation.removeWatchAsync(watchId);\n  if (headingEventSub) {\n    LocationEventEmitter.removeSubscription(headingEventSub);\n    headingEventSub = null;\n  }\n}\n// End Compass Module\n\nfunction _maybeInitializeEmitterSubscription() {\n  if (!deviceEventSubscription) {\n    deviceEventSubscription = LocationEventEmitter.addListener(\n      'Expo.locationChanged',\n      ({ watchId, location }: { watchId: string; location: LocationData }) => {\n        const callback = watchCallbacks[watchId];\n        if (callback) {\n          callback(location);\n        } else {\n          ExpoLocation.removeWatchAsync(watchId);\n        }\n      }\n    );\n  }\n}\n\nexport async function geocodeAsync(address: string): Promise<GeocodedLocation[]> {\n  return ExpoLocation.geocodeAsync(address).catch(error => {\n    const platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n\n    if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n      if (!googleApiKey) {\n        throw new CodedError(\n          error.code,\n          `${error.message} Please set a Google API Key to use geocoding.`\n        );\n      }\n      return _googleGeocodeAsync(address);\n    }\n    throw error;\n  });\n}\n\nexport async function reverseGeocodeAsync(location: {\n  latitude: number;\n  longitude: number;\n}): Promise<Address[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location should be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n  return ExpoLocation.reverseGeocodeAsync(location).catch(error => {\n    const platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n\n    if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n      if (!googleApiKey) {\n        throw new CodedError(\n          error.code,\n          `${error.message} Please set a Google API Key to use geocoding.`\n        );\n      }\n      return _googleReverseGeocodeAsync(location);\n    }\n    throw error;\n  });\n}\n\nexport function setApiKey(apiKey: string) {\n  googleApiKey = apiKey;\n}\n\nasync function _googleGeocodeAsync(address: string): Promise<GeocodedLocation[]> {\n  const result = await fetch(`${googleApiUrl}?key=${googleApiKey}&address=${encodeURI(address)}`);\n  const resultObject = await result.json();\n\n  if (resultObject.status === 'ZERO_RESULTS') {\n    return [];\n  }\n\n  assertGeocodeResults(resultObject);\n\n  return resultObject.results.map(result => {\n    let location = result.geometry.location;\n    // TODO: This is missing a lot of props\n    return {\n      latitude: location.lat,\n      longitude: location.lng,\n    };\n  });\n}\n\nasync function _googleReverseGeocodeAsync(options: {\n  latitude: number;\n  longitude: number;\n}): Promise<Address[]> {\n  const result = await fetch(\n    `${googleApiUrl}?key=${googleApiKey}&latlng=${options.latitude},${options.longitude}`\n  );\n  const resultObject = await result.json();\n\n  if (resultObject.status === 'ZERO_RESULTS') {\n    return [];\n  }\n\n  assertGeocodeResults(resultObject);\n\n  return resultObject.results.map(result => {\n    const address: any = {};\n\n    result.address_components.forEach(component => {\n      if (component.types.includes('locality')) {\n        address.city = component.long_name;\n      } else if (component.types.includes('street_address')) {\n        address.street = component.long_name;\n      } else if (component.types.includes('administrative_area_level_1')) {\n        address.region = component.long_name;\n      } else if (component.types.includes('country')) {\n        address.country = component.long_name;\n      } else if (component.types.includes('postal_code')) {\n        address.postalCode = component.long_name;\n      } else if (component.types.includes('point_of_interest')) {\n        address.name = component.long_name;\n      }\n    });\n    return address as Address;\n  });\n}\n\n// https://developers.google.com/maps/documentation/geocoding/intro\nfunction assertGeocodeResults(resultObject: any): void {\n  const { status, error_message } = resultObject;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(\n        status,\n        'the request could not be processed due to a server error. The request may succeed if you try again.'\n      );\n    }\n    throw new CodedError(status, `An error occurred during geocoding.`);\n  }\n}\n\n// Polyfill: navigator.geolocation.watchPosition\nfunction watchPosition(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback,\n  options: LocationOptions\n) {\n  _maybeInitializeEmitterSubscription();\n\n  const watchId = _getNextWatchId();\n  watchCallbacks[watchId] = success;\n\n  ExpoLocation.watchPositionImplAsync(watchId, options).catch(err => {\n    _removeWatcher(watchId);\n    error({ watchId, message: err.message, code: err.code });\n  });\n\n  return watchId;\n}\n\nexport async function watchPositionAsync(options: LocationOptions, callback: LocationCallback) {\n  _maybeInitializeEmitterSubscription();\n\n  const watchId = _getNextWatchId();\n  watchCallbacks[watchId] = callback;\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      _removeWatcher(watchId);\n    },\n  };\n}\n\n// Polyfill: navigator.geolocation.clearWatch\nfunction clearWatch(watchId: number) {\n  _removeWatcher(watchId);\n}\n\nfunction _removeWatcher(watchId) {\n  // Do nothing if we have already removed the subscription\n  if (!watchCallbacks[watchId]) {\n    return;\n  }\n\n  ExpoLocation.removeWatchAsync(watchId);\n  delete watchCallbacks[watchId];\n  if (Object.keys(watchCallbacks).length === 0 && deviceEventSubscription) {\n    LocationEventEmitter.removeSubscription(deviceEventSubscription);\n    deviceEventSubscription = null;\n  }\n}\n\ntype GeoSuccessCallback = (data: LocationData) => void;\ntype GeoErrorCallback = (error: any) => void;\n\nfunction getCurrentPosition(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback = () => {},\n  options: LocationOptions = {}\n): void {\n  invariant(typeof success === 'function', 'Must provide a valid success callback.');\n\n  invariant(typeof options === 'object', 'options must be an object.');\n\n  _getCurrentPositionAsyncWrapper(success, error, options);\n}\n\n// This function exists to let us continue to return undefined from getCurrentPosition, while still\n// using async/await for the internal implementation of it\nasync function _getCurrentPositionAsyncWrapper(\n  success: GeoSuccessCallback,\n  error: GeoErrorCallback,\n  options: LocationOptions\n): Promise<any> {\n  try {\n    await ExpoLocation.requestPermissionsAsync();\n    const result = await getCurrentPositionAsync(options);\n    success(result);\n  } catch (e) {\n    error(e);\n  }\n}\n\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.getPermissionsAsync();\n}\n\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.requestPermissionsAsync();\n}\n\n// --- Location service\n\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  invariant(taskName && typeof taskName === 'string', '`taskName` must be a non-empty string.');\n}\n\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\nexport function installWebGeolocationPolyfill(): void {\n  if (Platform.OS !== 'web') {\n    // Polyfill navigator.geolocation for interop with the core react-native and web API approach to\n    // geolocation\n    // @ts-ignore\n    window.navigator.geolocation = {\n      getCurrentPosition,\n      watchPosition,\n      clearWatch,\n\n      // We don't polyfill stopObserving, this is an internal method that probably should not even exist\n      // in react-native docs\n      stopObserving: () => {},\n    };\n  }\n}\n\nexport {\n  // For internal purposes\n  LocationEventEmitter as EventEmitter,\n  _getCurrentWatchId,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}