{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useLastNotificationResponse;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _react = require(\"react\");\nvar _NotificationsEmitter = require(\"./NotificationsEmitter\");\nvar _NotificationsEmitterModule = _interopRequireDefault(require(\"./NotificationsEmitterModule\"));\nfunction useLastNotificationResponse() {\n  var _useState = (0, _react.useState)(undefined),\n    _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n    lastNotificationResponse = _useState2[0],\n    setLastNotificationResponse = _useState2[1];\n  (0, _react.useLayoutEffect)(function () {\n    var subscription = (0, _NotificationsEmitter.addNotificationResponseReceivedListener)(function (response) {\n      setLastNotificationResponse(response);\n    });\n    return function () {\n      subscription.remove();\n    };\n  }, []);\n  (0, _react.useEffect)(function () {\n    _NotificationsEmitterModule.default.getLastNotificationResponseAsync == null ? void 0 : _NotificationsEmitterModule.default.getLastNotificationResponseAsync().then(function (response) {\n      setLastNotificationResponse(function (currentResponse) {\n        return currentResponse != null ? currentResponse : response;\n      });\n    });\n  }, []);\n  return lastNotificationResponse;\n}","map":{"version":3,"sources":["../src/useLastNotificationResponse.ts"],"names":[],"mappings":";;;;;;AAAA;AAGA;AACA;AASc,SAAU,2BAA2B,GAAA;EACjD,gBAAgE,IAAA,eAAQ,EAEtE,SAAS,CAAC;IAAA;IAFL,wBAAwB;IAAE,2BAA2B;EAK5D,IAAA,sBAAe,EAAC,YAAK;IACnB,IAAM,YAAY,GAAG,IAAA,6DAAuC,EAAC,UAAC,QAAQ,EAAI;MACxE,2BAA2B,CAAC,QAAQ,CAAC;IACvC,CAAC,CAAC;IACF,OAAO,YAAK;MACV,YAAY,CAAC,MAAM,EAAE;IACvB,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAKN,IAAA,gBAAS,EAAC,YAAK;IACb,mCAA0B,CAAC,gCAAgC,oBAA3D,mCAA0B,CAAC,gCAAgC,EAAI,CAAC,IAAI,CAAC,UAAC,QAAQ,EAAI;MAIhF,2BAA2B,CAAC,UAAC,eAAe;QAAA,OAAK,eAAe,WAAf,eAAe,GAAI,QAAQ;MAAA,EAAC;IAC/E,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO,wBAAwB;AACjC","sourcesContent":["import { useEffect, useLayoutEffect, useState } from 'react';\n\nimport { NotificationResponse } from './Notifications.types';\nimport { addNotificationResponseReceivedListener } from './NotificationsEmitter';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\n\n/**\n * Return value of this hook may be one of three types:\n * - `undefined` until we know what to return\n * - `null` until the app receives any notification response\n * - an object of `NotificationResponse` type - the response\n *   that has been received by the app most recently.\n */\nexport default function useLastNotificationResponse() {\n  const [lastNotificationResponse, setLastNotificationResponse] = useState<\n    NotificationResponse | null | undefined\n  >(undefined);\n\n  // useLayoutEffect ensures the listener is registered as soon as possible\n  useLayoutEffect(() => {\n    const subscription = addNotificationResponseReceivedListener((response) => {\n      setLastNotificationResponse(response);\n    });\n    return () => {\n      subscription.remove();\n    };\n  }, []);\n\n  // On each mount of this hook we fetch last notification response\n  // from the native module which is an \"always active listener\"\n  // and always returns the most recent response.\n  useEffect(() => {\n    NotificationsEmitterModule.getLastNotificationResponseAsync?.().then((response) => {\n      // We only update the state with the resolved value if it's empty,\n      // because if it's not empty it must have been populated by the `useLayoutEffect`\n      // listener which returns \"live\" values.\n      setLastNotificationResponse((currentResponse) => currentResponse ?? response);\n    });\n  }, []);\n\n  return lastNotificationResponse;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}