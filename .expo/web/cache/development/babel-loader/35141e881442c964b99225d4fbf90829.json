{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  getProviderStatusAsync: true,\n  enableNetworkProviderAsync: true,\n  getCurrentPositionAsync: true,\n  getLastKnownPositionAsync: true,\n  watchPositionAsync: true,\n  getHeadingAsync: true,\n  watchHeadingAsync: true,\n  geocodeAsync: true,\n  reverseGeocodeAsync: true,\n  getPermissionsAsync: true,\n  requestPermissionsAsync: true,\n  getForegroundPermissionsAsync: true,\n  requestForegroundPermissionsAsync: true,\n  useForegroundPermissions: true,\n  getBackgroundPermissionsAsync: true,\n  requestBackgroundPermissionsAsync: true,\n  useBackgroundPermissions: true,\n  hasServicesEnabledAsync: true,\n  isBackgroundLocationAvailableAsync: true,\n  startLocationUpdatesAsync: true,\n  stopLocationUpdatesAsync: true,\n  hasStartedLocationUpdatesAsync: true,\n  startGeofencingAsync: true,\n  stopGeofencingAsync: true,\n  hasStartedGeofencingAsync: true,\n  PermissionStatus: true,\n  Accuracy: true,\n  ActivityType: true,\n  GeofencingEventType: true,\n  GeofencingRegionState: true,\n  EventEmitter: true,\n  setGoogleApiKey: true,\n  _getCurrentWatchId: true,\n  installWebGeolocationPolyfill: true\n};\nObject.defineProperty(exports, \"Accuracy\", {\n  enumerable: true,\n  get: function get() {\n    return _Location.LocationAccuracy;\n  }\n});\nObject.defineProperty(exports, \"ActivityType\", {\n  enumerable: true,\n  get: function get() {\n    return _Location.LocationActivityType;\n  }\n});\nObject.defineProperty(exports, \"EventEmitter\", {\n  enumerable: true,\n  get: function get() {\n    return _LocationEventEmitter.LocationEventEmitter;\n  }\n});\nObject.defineProperty(exports, \"GeofencingEventType\", {\n  enumerable: true,\n  get: function get() {\n    return _Location.LocationGeofencingEventType;\n  }\n});\nObject.defineProperty(exports, \"GeofencingRegionState\", {\n  enumerable: true,\n  get: function get() {\n    return _Location.LocationGeofencingRegionState;\n  }\n});\nObject.defineProperty(exports, \"PermissionStatus\", {\n  enumerable: true,\n  get: function get() {\n    return _expoModulesCore.PermissionStatus;\n  }\n});\nObject.defineProperty(exports, \"_getCurrentWatchId\", {\n  enumerable: true,\n  get: function get() {\n    return _LocationSubscribers._getCurrentWatchId;\n  }\n});\nexports.enableNetworkProviderAsync = enableNetworkProviderAsync;\nexports.geocodeAsync = geocodeAsync;\nexports.getBackgroundPermissionsAsync = getBackgroundPermissionsAsync;\nexports.getCurrentPositionAsync = getCurrentPositionAsync;\nexports.getForegroundPermissionsAsync = getForegroundPermissionsAsync;\nexports.getHeadingAsync = getHeadingAsync;\nexports.getLastKnownPositionAsync = getLastKnownPositionAsync;\nexports.getPermissionsAsync = getPermissionsAsync;\nexports.getProviderStatusAsync = getProviderStatusAsync;\nexports.hasServicesEnabledAsync = hasServicesEnabledAsync;\nexports.hasStartedGeofencingAsync = hasStartedGeofencingAsync;\nexports.hasStartedLocationUpdatesAsync = hasStartedLocationUpdatesAsync;\nObject.defineProperty(exports, \"installWebGeolocationPolyfill\", {\n  enumerable: true,\n  get: function get() {\n    return _GeolocationPolyfill.installWebGeolocationPolyfill;\n  }\n});\nexports.isBackgroundLocationAvailableAsync = isBackgroundLocationAvailableAsync;\nexports.requestBackgroundPermissionsAsync = requestBackgroundPermissionsAsync;\nexports.requestForegroundPermissionsAsync = requestForegroundPermissionsAsync;\nexports.requestPermissionsAsync = requestPermissionsAsync;\nexports.reverseGeocodeAsync = reverseGeocodeAsync;\nObject.defineProperty(exports, \"setGoogleApiKey\", {\n  enumerable: true,\n  get: function get() {\n    return _LocationGoogleGeocoding.setGoogleApiKey;\n  }\n});\nexports.startGeofencingAsync = startGeofencingAsync;\nexports.startLocationUpdatesAsync = startLocationUpdatesAsync;\nexports.stopGeofencingAsync = stopGeofencingAsync;\nexports.stopLocationUpdatesAsync = stopLocationUpdatesAsync;\nexports.useForegroundPermissions = exports.useBackgroundPermissions = void 0;\nexports.watchHeadingAsync = watchHeadingAsync;\nexports.watchPositionAsync = watchPositionAsync;\nvar _expoModulesCore = require(\"expo-modules-core\");\nvar _ExpoLocation = _interopRequireDefault(require(\"./ExpoLocation\"));\nvar _Location = require(\"./Location.types\");\nObject.keys(_Location).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _Location[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Location[key];\n    }\n  });\n});\nvar _LocationEventEmitter = require(\"./LocationEventEmitter\");\nvar _LocationGoogleGeocoding = require(\"./LocationGoogleGeocoding\");\nvar _LocationSubscribers = require(\"./LocationSubscribers\");\nvar _GeolocationPolyfill = require(\"./GeolocationPolyfill\");\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction getProviderStatusAsync() {\n  return _regeneratorRuntime().async(function getProviderStatusAsync$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        return _context.abrupt(\"return\", _ExpoLocation.default.getProviderStatusAsync());\n      case 1:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction enableNetworkProviderAsync() {\n  return _regeneratorRuntime().async(function enableNetworkProviderAsync$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        if (!(_expoModulesCore.Platform.OS === 'android')) {\n          _context2.next = 2;\n          break;\n        }\n        return _context2.abrupt(\"return\", _ExpoLocation.default.enableNetworkProviderAsync());\n      case 2:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getCurrentPositionAsync() {\n  var options,\n    _args3 = arguments;\n  return _regeneratorRuntime().async(function getCurrentPositionAsync$(_context3) {\n    while (1) switch (_context3.prev = _context3.next) {\n      case 0:\n        options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n        return _context3.abrupt(\"return\", _ExpoLocation.default.getCurrentPositionAsync(options));\n      case 2:\n      case \"end\":\n        return _context3.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getLastKnownPositionAsync() {\n  var options,\n    _args4 = arguments;\n  return _regeneratorRuntime().async(function getLastKnownPositionAsync$(_context4) {\n    while (1) switch (_context4.prev = _context4.next) {\n      case 0:\n        options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n        return _context4.abrupt(\"return\", _ExpoLocation.default.getLastKnownPositionAsync(options));\n      case 2:\n      case \"end\":\n        return _context4.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction watchPositionAsync(options, callback) {\n  var watchId;\n  return _regeneratorRuntime().async(function watchPositionAsync$(_context5) {\n    while (1) switch (_context5.prev = _context5.next) {\n      case 0:\n        watchId = _LocationSubscribers.LocationSubscriber.registerCallback(callback);\n        _context5.next = 3;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.watchPositionImplAsync(watchId, options));\n      case 3:\n        return _context5.abrupt(\"return\", {\n          remove: function remove() {\n            _LocationSubscribers.LocationSubscriber.unregisterCallback(watchId);\n          }\n        });\n      case 4:\n      case \"end\":\n        return _context5.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getHeadingAsync() {\n  return _regeneratorRuntime().async(function getHeadingAsync$(_context7) {\n    while (1) switch (_context7.prev = _context7.next) {\n      case 0:\n        return _context7.abrupt(\"return\", new Promise(function _callee(resolve) {\n          var tries, subscription;\n          return _regeneratorRuntime().async(function _callee$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                tries = 0;\n                _context6.next = 3;\n                return _regeneratorRuntime().awrap(watchHeadingAsync(function (heading) {\n                  if (heading.accuracy > 1 || tries > 5) {\n                    subscription.remove();\n                    resolve(heading);\n                  } else {\n                    tries += 1;\n                  }\n                }));\n              case 3:\n                subscription = _context6.sent;\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }, null, null, null, Promise);\n        }));\n      case 1:\n      case \"end\":\n        return _context7.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction watchHeadingAsync(callback) {\n  var watchId;\n  return _regeneratorRuntime().async(function watchHeadingAsync$(_context8) {\n    while (1) switch (_context8.prev = _context8.next) {\n      case 0:\n        watchId = _LocationSubscribers.HeadingSubscriber.registerCallback(callback);\n        _context8.next = 3;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.watchDeviceHeading(watchId));\n      case 3:\n        return _context8.abrupt(\"return\", {\n          remove: function remove() {\n            _LocationSubscribers.HeadingSubscriber.unregisterCallback(watchId);\n          }\n        });\n      case 4:\n      case \"end\":\n        return _context8.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction geocodeAsync(address, options) {\n  return _regeneratorRuntime().async(function geocodeAsync$(_context9) {\n    while (1) switch (_context9.prev = _context9.next) {\n      case 0:\n        if (!(typeof address !== 'string')) {\n          _context9.next = 2;\n          break;\n        }\n        throw new TypeError(\"Address to geocode must be a string. Got \" + address + \" instead.\");\n      case 2:\n        if (!(options != null && options.useGoogleMaps || _expoModulesCore.Platform.OS === 'web')) {\n          _context9.next = 6;\n          break;\n        }\n        _context9.next = 5;\n        return _regeneratorRuntime().awrap((0, _LocationGoogleGeocoding.googleGeocodeAsync)(address));\n      case 5:\n        return _context9.abrupt(\"return\", _context9.sent);\n      case 6:\n        _context9.next = 8;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.geocodeAsync(address));\n      case 8:\n        return _context9.abrupt(\"return\", _context9.sent);\n      case 9:\n      case \"end\":\n        return _context9.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction reverseGeocodeAsync(location, options) {\n  return _regeneratorRuntime().async(function reverseGeocodeAsync$(_context10) {\n    while (1) switch (_context10.prev = _context10.next) {\n      case 0:\n        if (!(typeof location.latitude !== 'number' || typeof location.longitude !== 'number')) {\n          _context10.next = 2;\n          break;\n        }\n        throw new TypeError('Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.');\n      case 2:\n        if (!(options != null && options.useGoogleMaps || _expoModulesCore.Platform.OS === 'web')) {\n          _context10.next = 6;\n          break;\n        }\n        _context10.next = 5;\n        return _regeneratorRuntime().awrap((0, _LocationGoogleGeocoding.googleReverseGeocodeAsync)(location));\n      case 5:\n        return _context10.abrupt(\"return\", _context10.sent);\n      case 6:\n        _context10.next = 8;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.reverseGeocodeAsync(location));\n      case 8:\n        return _context10.abrupt(\"return\", _context10.sent);\n      case 9:\n      case \"end\":\n        return _context10.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getPermissionsAsync() {\n  return _regeneratorRuntime().async(function getPermissionsAsync$(_context11) {\n    while (1) switch (_context11.prev = _context11.next) {\n      case 0:\n        console.warn(\"\\\"getPermissionsAsync()\\\" is now deprecated. Please use \\\"getForegroundPermissionsAsync()\\\" or \\\"getBackgroundPermissionsAsync()\\\" instead.\");\n        _context11.next = 3;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.getPermissionsAsync());\n      case 3:\n        return _context11.abrupt(\"return\", _context11.sent);\n      case 4:\n      case \"end\":\n        return _context11.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction requestPermissionsAsync() {\n  return _regeneratorRuntime().async(function requestPermissionsAsync$(_context12) {\n    while (1) switch (_context12.prev = _context12.next) {\n      case 0:\n        console.warn(\"\\\"requestPermissionsAsync()\\\" is now deprecated. Please use \\\"requestForegroundPermissionsAsync()\\\" or \\\"requestBackgroundPermissionsAsync()\\\" instead.\");\n        _context12.next = 3;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.requestPermissionsAsync());\n      case 3:\n        return _context12.abrupt(\"return\", _context12.sent);\n      case 4:\n      case \"end\":\n        return _context12.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction getForegroundPermissionsAsync() {\n  return _regeneratorRuntime().async(function getForegroundPermissionsAsync$(_context13) {\n    while (1) switch (_context13.prev = _context13.next) {\n      case 0:\n        _context13.next = 2;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.getForegroundPermissionsAsync());\n      case 2:\n        return _context13.abrupt(\"return\", _context13.sent);\n      case 3:\n      case \"end\":\n        return _context13.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction requestForegroundPermissionsAsync() {\n  return _regeneratorRuntime().async(function requestForegroundPermissionsAsync$(_context14) {\n    while (1) switch (_context14.prev = _context14.next) {\n      case 0:\n        _context14.next = 2;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.requestForegroundPermissionsAsync());\n      case 2:\n        return _context14.abrupt(\"return\", _context14.sent);\n      case 3:\n      case \"end\":\n        return _context14.stop();\n    }\n  }, null, null, null, Promise);\n}\nvar useForegroundPermissions = (0, _expoModulesCore.createPermissionHook)({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync\n});\nexports.useForegroundPermissions = useForegroundPermissions;\nfunction getBackgroundPermissionsAsync() {\n  return _regeneratorRuntime().async(function getBackgroundPermissionsAsync$(_context15) {\n    while (1) switch (_context15.prev = _context15.next) {\n      case 0:\n        _context15.next = 2;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.getBackgroundPermissionsAsync());\n      case 2:\n        return _context15.abrupt(\"return\", _context15.sent);\n      case 3:\n      case \"end\":\n        return _context15.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction requestBackgroundPermissionsAsync() {\n  return _regeneratorRuntime().async(function requestBackgroundPermissionsAsync$(_context16) {\n    while (1) switch (_context16.prev = _context16.next) {\n      case 0:\n        _context16.next = 2;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.requestBackgroundPermissionsAsync());\n      case 2:\n        return _context16.abrupt(\"return\", _context16.sent);\n      case 3:\n      case \"end\":\n        return _context16.stop();\n    }\n  }, null, null, null, Promise);\n}\nvar useBackgroundPermissions = (0, _expoModulesCore.createPermissionHook)({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync\n});\nexports.useBackgroundPermissions = useBackgroundPermissions;\nfunction hasServicesEnabledAsync() {\n  return _regeneratorRuntime().async(function hasServicesEnabledAsync$(_context17) {\n    while (1) switch (_context17.prev = _context17.next) {\n      case 0:\n        _context17.next = 2;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.hasServicesEnabledAsync());\n      case 2:\n        return _context17.abrupt(\"return\", _context17.sent);\n      case 3:\n      case \"end\":\n        return _context17.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction _validateTaskName(taskName) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(\"`taskName` must be a non-empty string. Got \" + taskName + \" instead.\");\n  }\n}\nfunction isBackgroundLocationAvailableAsync() {\n  var providerStatus;\n  return _regeneratorRuntime().async(function isBackgroundLocationAvailableAsync$(_context18) {\n    while (1) switch (_context18.prev = _context18.next) {\n      case 0:\n        _context18.next = 2;\n        return _regeneratorRuntime().awrap(getProviderStatusAsync());\n      case 2:\n        providerStatus = _context18.sent;\n        return _context18.abrupt(\"return\", providerStatus.backgroundModeEnabled);\n      case 4:\n      case \"end\":\n        return _context18.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction startLocationUpdatesAsync(taskName) {\n  var options,\n    _args19 = arguments;\n  return _regeneratorRuntime().async(function startLocationUpdatesAsync$(_context19) {\n    while (1) switch (_context19.prev = _context19.next) {\n      case 0:\n        options = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : {\n          accuracy: _Location.LocationAccuracy.Balanced\n        };\n        _validateTaskName(taskName);\n        _context19.next = 4;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.startLocationUpdatesAsync(taskName, options));\n      case 4:\n      case \"end\":\n        return _context19.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction stopLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime().async(function stopLocationUpdatesAsync$(_context20) {\n    while (1) switch (_context20.prev = _context20.next) {\n      case 0:\n        _validateTaskName(taskName);\n        _context20.next = 3;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.stopLocationUpdatesAsync(taskName));\n      case 3:\n      case \"end\":\n        return _context20.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction hasStartedLocationUpdatesAsync(taskName) {\n  return _regeneratorRuntime().async(function hasStartedLocationUpdatesAsync$(_context21) {\n    while (1) switch (_context21.prev = _context21.next) {\n      case 0:\n        _validateTaskName(taskName);\n        return _context21.abrupt(\"return\", _ExpoLocation.default.hasStartedLocationUpdatesAsync(taskName));\n      case 2:\n      case \"end\":\n        return _context21.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction _validateRegions(regions) {\n  if (!regions || regions.length === 0) {\n    throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');\n  }\n  for (var _iterator = _createForOfIteratorHelperLoose(regions), _step; !(_step = _iterator()).done;) {\n    var region = _step.value;\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(\"Region's latitude must be a number. Got '\" + region.latitude + \"' instead.\");\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\"Region's longitude must be a number. Got '\" + region.longitude + \"' instead.\");\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(\"Region's radius must be a number. Got '\" + region.radius + \"' instead.\");\n    }\n  }\n}\nfunction startGeofencingAsync(taskName) {\n  var regions,\n    _args22 = arguments;\n  return _regeneratorRuntime().async(function startGeofencingAsync$(_context22) {\n    while (1) switch (_context22.prev = _context22.next) {\n      case 0:\n        regions = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : [];\n        _validateTaskName(taskName);\n        _validateRegions(regions);\n        _context22.next = 5;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.startGeofencingAsync(taskName, {\n          regions: regions\n        }));\n      case 5:\n      case \"end\":\n        return _context22.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction stopGeofencingAsync(taskName) {\n  return _regeneratorRuntime().async(function stopGeofencingAsync$(_context23) {\n    while (1) switch (_context23.prev = _context23.next) {\n      case 0:\n        _validateTaskName(taskName);\n        _context23.next = 3;\n        return _regeneratorRuntime().awrap(_ExpoLocation.default.stopGeofencingAsync(taskName));\n      case 3:\n      case \"end\":\n        return _context23.stop();\n    }\n  }, null, null, null, Promise);\n}\nfunction hasStartedGeofencingAsync(taskName) {\n  return _regeneratorRuntime().async(function hasStartedGeofencingAsync$(_context24) {\n    while (1) switch (_context24.prev = _context24.next) {\n      case 0:\n        _validateTaskName(taskName);\n        return _context24.abrupt(\"return\", _ExpoLocation.default.hasStartedGeofencingAsync(taskName));\n      case 2:\n      case \"end\":\n        return _context24.stop();\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"sources":["../src/Location.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionStatus,\n  PermissionResponse,\n  PermissionHookOptions,\n  createPermissionHook,\n  Platform,\n} from 'expo-modules-core';\n\nimport ExpoLocation from './ExpoLocation';\nimport {\n  LocationAccuracy,\n  LocationCallback,\n  LocationGeocodedAddress,\n  LocationGeocodedLocation,\n  LocationHeadingCallback,\n  LocationHeadingObject,\n  LocationLastKnownOptions,\n  LocationObject,\n  LocationOptions,\n  LocationPermissionResponse,\n  LocationProviderStatus,\n  LocationRegion,\n  LocationSubscription,\n  LocationTaskOptions,\n  LocationActivityType,\n  LocationGeofencingEventType,\n  LocationGeofencingRegionState,\n  LocationGeocodingOptions,\n} from './Location.types';\nimport { LocationEventEmitter } from './LocationEventEmitter';\nimport {\n  setGoogleApiKey,\n  googleGeocodeAsync,\n  googleReverseGeocodeAsync,\n} from './LocationGoogleGeocoding';\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from './LocationSubscribers';\n\n// @needsAudit\n/**\n * Check status of location providers.\n * @return A promise which fulfills with an object of type [LocationProviderStatus](#locationproviderstatus).\n */\nexport async function getProviderStatusAsync(): Promise<LocationProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to turn on high accuracy location mode which enables network provider that uses\n * Google Play services to improve location accuracy and location-based services.\n * @return A promise resolving as soon as the user accepts the dialog. Rejects if denied.\n */\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\n// @needsAudit\n/**\n * Requests for one-time delivery of the user's current location.\n * Depending on given `accuracy` option it may take some time to resolve,\n * especially when you're inside a building.\n * > __Note:__ Calling it causes the location manager to obtain a location fix which may take several\n * > seconds. Consider using [`Location.getLastKnownPositionAsync`](#locationgetlastknownpositionasyncoptions)\n * > if you expect to get a quick response and high accuracy is not required.\n * @param options\n * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject).\n */\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationObject> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Gets the last known position of the device or `null` if it's not available or doesn't match given\n * requirements such as maximum age or required accuracy.\n * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current\n * location, but keep in mind the returned location may not be up-to-date.\n * @param options\n * @return A promise which fulfills with an object of type [LocationObject](#locationobject) or\n * `null` if it's not available or doesn't match given requirements such as maximum age or required\n * accuracy.\n */\nexport async function getLastKnownPositionAsync(\n  options: LocationLastKnownOptions = {}\n): Promise<LocationObject | null> {\n  return ExpoLocation.getLastKnownPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Subscribe to location updates from the device. Please note that updates will only occur while the\n * application is in the foreground. To get location updates while in background you'll need to use\n * [Location.startLocationUpdatesAsync](#locationstartlocationupdatesasynctaskname-options).\n * @param options\n * @param callback This function is called on each location update. It receives an object of type\n * [`LocationObject`](#locationobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchPositionAsync(\n  options: LocationOptions,\n  callback: LocationCallback\n): Promise<LocationSubscription> {\n  const watchId = LocationSubscriber.registerCallback(callback);\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      LocationSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Gets the current heading information from the device. To simplify, it calls `watchHeadingAsync`\n * and waits for a couple of updates, and then returns the one that is accurate enough.\n * @return A promise which fulfills with an object of type [LocationHeadingObject](#locationheadingobject).\n */\nexport async function getHeadingAsync(): Promise<LocationHeadingObject> {\n  return new Promise(async (resolve) => {\n    let tries = 0;\n\n    const subscription = await watchHeadingAsync((heading) => {\n      if (heading.accuracy > 1 || tries > 5) {\n        subscription.remove();\n        resolve(heading);\n      } else {\n        tries += 1;\n      }\n    });\n  });\n}\n\n// @needsAudit\n/**\n * Subscribe to compass updates from the device.\n * @param callback This function is called on each compass update. It receives an object of type\n * [LocationHeadingObject](#locationheadingobject) as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback\n): Promise<LocationSubscription> {\n  const watchId = HeadingSubscriber.registerCallback(callback);\n  await ExpoLocation.watchDeviceHeading(watchId);\n\n  return {\n    remove() {\n      HeadingSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Geocode an address string to latitude-longitude location.\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param address A string representing address, eg. `\"Baker Street London\"`.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedLocation`](#locationgeocodedlocation) objects.\n */\nexport async function geocodeAsync(\n  address: string,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedLocation[]> {\n  if (typeof address !== 'string') {\n    throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);\n  }\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    return await googleGeocodeAsync(address);\n  }\n  return await ExpoLocation.geocodeAsync(address);\n}\n\n// @needsAudit\n/**\n * Reverse geocode a location to postal address.\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\n * > before geocoding can be used.\n * @param location An object representing a location.\n * @param options\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedAddress`](#locationgeocodedaddress) objects.\n */\nexport async function reverseGeocodeAsync(\n  location: Pick<LocationGeocodedLocation, 'latitude' | 'longitude'>,\n  options?: LocationGeocodingOptions\n): Promise<LocationGeocodedAddress[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\n    return await googleReverseGeocodeAsync(location);\n  }\n  return await ExpoLocation.reverseGeocodeAsync(location);\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`getForegroundPermissionsAsync`](#locationgetforegroundpermissionsasync) or [`getBackgroundPermissionsAsync`](#locationgetbackgroundpermissionsasync) instead.\n */\nexport async function getPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"getPermissionsAsync()\" is now deprecated. Please use \"getForegroundPermissionsAsync()\" or \"getBackgroundPermissionsAsync()\" instead.`\n  );\n  return await ExpoLocation.getPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location.\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\n * @deprecated Use [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync) or [`requestBackgroundPermissionsAsync`](#locationrequestbackgroundpermissionsasync) instead.\n */\nexport async function requestPermissionsAsync(): Promise<LocationPermissionResponse> {\n  console.warn(\n    `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestForegroundPermissionsAsync()\" or \"requestBackgroundPermissionsAsync()\" instead.`\n  );\n\n  return await ExpoLocation.requestPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.getForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.requestForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestForegroundPermissionsAsync` and `getForegroundPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useForegroundPermissions();\n * ```\n */\nexport const useForegroundPermissions = createPermissionHook({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the background.\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function getBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.getBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the background.\n * On __Android 11 or higher__: this method will open the system settings page - before that happens\n * you should explain to the user why your application needs background location permission.\n * For example, you can use `Modal` component from `react-native` to do that.\n * > __Note__: Foreground permissions should be granted before asking for the background permissions\n * (your app can't obtain background permission without foreground permission).\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\n */\nexport async function requestBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.requestBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestBackgroundPermissionsAsync` and `getBackgroundPermissionsAsync` to\n * interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useBackgroundPermissions();\n * ```\n */\nexport const useBackgroundPermissions = createPermissionHook({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync,\n});\n\n// --- Location service\n\n// @needsAudit\n/**\n * Checks whether location services are enabled by the user.\n * @return A promise which fulfills to `true` if location services are enabled on the device,\n * or `false` if not.\n */\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validateTaskName(taskName: string) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);\n  }\n}\n\n// @docsMissing\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\n// @needsAudit\n/**\n * Registers for receiving location updates that can also come when the app is in the background.\n * @param taskName Name of the task receiving location updates.\n * @param options An object of options passed to the location manager.\n * @return A promise resolving once the task with location updates is registered.\n *\n * # Task parameters\n *\n * Background location task will be receiving following data:\n * - `locations` - An array of the new locations.\n *\n * ```ts\n * import * as TaskManager from 'expo-task-manager';\n *\n * TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { locations }, error }) => {\n *  if (error) {\n *    // check `error.message` for more details.\n *    return;\n *  }\n *  console.log('Received new locations', locations);\n * });\n * ```\n */\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task.\n * @param taskName Name of the background location task to stop.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the location task to check.\n * @return A promise which fulfills with boolean value indicating whether the location task is\n * started or not.\n */\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\n// @needsAudit\n/**\n * Starts geofencing for given regions. When the new event comes, the task with specified name will\n * be called with the region that the device enter to or exit from.\n * If you want to add or remove regions from already running geofencing task, you can just call\n * `startGeofencingAsync` again with the new array of regions.\n * @param taskName Name of the task that will be called when the device enters or exits from specified regions.\n * @param regions Array of region objects to be geofenced.\n * @return A promise resolving as soon as the task is registered.\n *\n * # Task parameters\n *\n * Geofencing task will be receiving following data:\n *  - `eventType` - Indicates the reason for calling the task, which can be triggered by entering or exiting the region.\n *    See [GeofencingEventType](#geofencingeventtype).\n *  - `region` - Object containing details about updated region. See [LocationRegion](#locationregion) for more details.\n *\n * # Example\n * ```ts\n * import { GeofencingEventType } from 'expo-location';\n * import * as TaskManager from 'expo-task-manager';\n *\n *  TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { eventType, region }, error }) => {\n *   if (error) {\n *     // check `error.message` for more details.\n *     return;\n *   }\n *   if (eventType === GeofencingEventType.Enter) {\n *     console.log(\"You've entered region:\", region);\n *   } else if (eventType === GeofencingEventType.Exit) {\n *     console.log(\"You've left region:\", region);\n *   }\n * });\n * ```\n */\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validateTaskName(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task. It unregisters the background task so the app will not be\n * receiving any updates, especially in the background.\n * @param taskName Name of the task to unregister.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validateTaskName(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the geofencing task to check.\n * @return A promise which fulfills with boolean value indicating whether the geofencing task is\n * started or not.\n */\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validateTaskName(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\n\nexport {\n  LocationAccuracy as Accuracy,\n  LocationActivityType as ActivityType,\n  LocationGeofencingEventType as GeofencingEventType,\n  LocationGeofencingRegionState as GeofencingRegionState,\n  PermissionStatus,\n  PermissionHookOptions,\n  setGoogleApiKey,\n};\n\nexport { installWebGeolocationPolyfill } from './GeolocationPolyfill';\nexport * from './Location.types';\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}