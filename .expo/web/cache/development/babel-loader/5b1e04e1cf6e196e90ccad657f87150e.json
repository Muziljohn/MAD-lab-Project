{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nexport default function getStateFromPath(path) {\n  var _ref;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var initialRoutes = [];\n  var configs = (_ref = []).concat.apply(_ref, _toConsumableArray(Object.keys(options).map(function (key) {\n    return createNormalizedConfigs(key, options, [], initialRoutes);\n  }))).sort(function (a, b) {\n    return b.pattern.split('/').length - a.pattern.split('/').length;\n  });\n  var remaining = path.replace(/\\/+/g, '/').replace(/^\\//, '').replace(/\\?.*$/, '');\n  remaining = remaining.endsWith('/') ? remaining : \"\".concat(remaining, \"/\");\n  if (remaining === '/') {\n    var match = configs.find(function (config) {\n      return config.path === '' && config.routeNames.every(function (name) {\n        var _configs$find;\n        return !((_configs$find = configs.find(function (c) {\n          return c.screen === name;\n        })) === null || _configs$find === void 0 ? void 0 : _configs$find.path);\n      });\n    });\n    if (match) {\n      return createNestedStateObject(match.routeNames.map(function (name, i, self) {\n        if (i === self.length - 1) {\n          return {\n            name: name,\n            params: parseQueryParams(path, match.parse)\n          };\n        }\n        return {\n          name: name\n        };\n      }), initialRoutes);\n    }\n    return undefined;\n  }\n  var result;\n  var current;\n  var _loop = function _loop() {\n    var routeNames = void 0;\n    var allParams = void 0;\n    var _loop3 = function _loop3(config) {\n      if (!config.regex) {\n        return \"continue\";\n      }\n      var match = remaining.match(config.regex);\n      if (match) {\n        routeNames = _toConsumableArray(config.routeNames);\n        var paramPatterns = config.pattern.split('/').filter(function (p) {\n          return p.startsWith(':');\n        });\n        if (paramPatterns.length) {\n          allParams = paramPatterns.reduce(function (acc, p, i) {\n            var value = match[(i + 1) * 2].replace(/\\//, '');\n            acc[p] = value;\n            return acc;\n          }, {});\n        }\n        remaining = remaining.replace(match[1], '');\n        return \"break\";\n      }\n    };\n    _loop2: for (var _iterator = _createForOfIteratorHelperLoose(configs), _step; !(_step = _iterator()).done;) {\n      var config = _step.value;\n      var _ret = _loop3(config);\n      switch (_ret) {\n        case \"continue\":\n          continue;\n        case \"break\":\n          break _loop2;\n      }\n    }\n    if (routeNames === undefined) {\n      var segments = remaining.split('/');\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n    var state = createNestedStateObject(routeNames.map(function (name) {\n      var config = configs.find(function (c) {\n        return c.screen === name;\n      });\n      var params;\n      if (allParams && (config === null || config === void 0 ? void 0 : config.path)) {\n        var pattern = config.path;\n        if (pattern) {\n          var paramPatterns = pattern.split('/').filter(function (p) {\n            return p.startsWith(':');\n          });\n          if (paramPatterns.length) {\n            params = paramPatterns.reduce(function (acc, p) {\n              var key = p.replace(/^:/, '').replace(/\\?$/, '');\n              var value = allParams[p];\n              if (value) {\n                acc[key] = config.parse && config.parse[key] ? config.parse[key](value) : value;\n              }\n              return acc;\n            }, {});\n          }\n        }\n      }\n      if (params && Object.keys(params).length) {\n        return {\n          name: name,\n          params: params\n        };\n      }\n      return {\n        name: name\n      };\n    }), initialRoutes);\n    if (current) {\n      while ((_current = current) === null || _current === void 0 ? void 0 : _current.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n      current.routes[((_current2 = current) === null || _current2 === void 0 ? void 0 : _current2.index) || 0].state = state;\n    } else {\n      result = state;\n    }\n    current = state;\n  };\n  while (remaining) {\n    var _current2;\n    var _current;\n    _loop();\n  }\n  if (current == null || result == null) {\n    return undefined;\n  }\n  var route = findFocusedRoute(current);\n  var params = parseQueryParams(path, findParseConfigForRoute(route.name, configs));\n  if (params) {\n    route.params = _objectSpread(_objectSpread({}, route.params), params);\n  }\n  return result;\n}\nfunction joinPaths() {\n  var _ref2;\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n  return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n}\nfunction createNormalizedConfigs(screen, routeConfig) {\n  var routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var initials = arguments.length > 3 ? arguments[3] : undefined;\n  var parentPattern = arguments.length > 4 ? arguments[4] : undefined;\n  var configs = [];\n  routeNames.push(screen);\n  var config = routeConfig[screen];\n  if (typeof config === 'string') {\n    var pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n    configs.push(createConfigItem(screen, routeNames, pattern, config));\n  } else if (typeof config === 'object') {\n    var _pattern;\n    if (typeof config.path === 'string') {\n      _pattern = config.exact !== true && parentPattern ? joinPaths(parentPattern, config.path) : config.path;\n      configs.push(createConfigItem(screen, routeNames, _pattern, config.path, config.parse));\n    }\n    if (config.screens) {\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          connectedRoutes: Object.keys(config.screens)\n        });\n      }\n      Object.keys(config.screens).forEach(function (nestedConfig) {\n        var result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, _pattern);\n        configs.push.apply(configs, _toConsumableArray(result));\n      });\n    }\n  }\n  routeNames.pop();\n  return configs;\n}\nfunction createConfigItem(screen, routeNames, pattern, path, parse) {\n  pattern = pattern.split('/').filter(Boolean).join('/');\n  var regex = pattern ? new RegExp(\"^(\".concat(pattern.split('/').map(function (it) {\n    if (it.startsWith(':')) {\n      return \"(([^/]+\\\\/)\".concat(it.endsWith('?') ? '?' : '', \")\");\n    }\n    return \"\".concat(escape(it), \"\\\\/\");\n  }).join(''), \")\")) : undefined;\n  return {\n    screen: screen,\n    regex: regex,\n    pattern: pattern,\n    path: path,\n    routeNames: _toConsumableArray(routeNames),\n    parse: parse\n  };\n}\nfunction findParseConfigForRoute(routeName, flatConfig) {\n  for (var _iterator2 = _createForOfIteratorHelperLoose(flatConfig), _step2; !(_step2 = _iterator2()).done;) {\n    var config = _step2.value;\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\nfunction findInitialRoute(routeName, initialRoutes) {\n  for (var _iterator3 = _createForOfIteratorHelperLoose(initialRoutes), _step3; !(_step3 = _iterator3()).done;) {\n    var config = _step3.value;\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName ? undefined : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\nfunction createStateObject(initialRoute, routeName, params, isEmpty) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, {\n          name: routeName,\n          params: params\n        }]\n      };\n    } else {\n      return {\n        routes: [{\n          name: routeName,\n          params: params\n        }]\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, {\n          name: routeName,\n          params: params,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    } else {\n      return {\n        routes: [{\n          name: routeName,\n          params: params,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    }\n  }\n}\nfunction createNestedStateObject(routes, initialRoutes) {\n  var state;\n  var route = routes.shift();\n  var initialRoute = findInitialRoute(route.name, initialRoutes);\n  state = createStateObject(initialRoute, route.name, route.params, routes.length === 0);\n  if (routes.length > 0) {\n    var nestedState = state;\n    while (route = routes.shift()) {\n      initialRoute = findInitialRoute(route.name, initialRoutes);\n      var nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n      nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route.name, route.params, routes.length === 0);\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state;\n      }\n    }\n  }\n  return state;\n}\nfunction findFocusedRoute(state) {\n  var _current4;\n  var current = state;\n  while ((_current3 = current) === null || _current3 === void 0 ? void 0 : _current3.routes[current.index || 0].state) {\n    var _current3;\n    current = current.routes[current.index || 0].state;\n  }\n  var route = current.routes[((_current4 = current) === null || _current4 === void 0 ? void 0 : _current4.index) || 0];\n  return route;\n}\nfunction parseQueryParams(path, parseConfig) {\n  var query = path.split('?')[1];\n  var params = queryString.parse(query);\n  if (parseConfig) {\n    Object.keys(params).forEach(function (name) {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n  return Object.keys(params).length ? params : undefined;\n}","map":{"version":3,"sources":["getStateFromPath.tsx"],"names":["escape","queryString","getStateFromPath","path","options","initialRoutes","configs","concat","Object","keys","map","key","createNormalizedConfigs","sort","a","b","pattern","split","length","remaining","replace","endsWith","match","find","config","routeNames","every","name","c","screen","createNestedStateObject","i","self","params","parseQueryParams","parse","undefined","result","current","allParams","regex","paramPatterns","filter","p","startsWith","reduce","acc","value","segments","decodeURIComponent","shift","join","state","routes","index","route","findFocusedRoute","findParseConfigForRoute","joinPaths","paths","Boolean","routeConfig","initials","parentPattern","push","createConfigItem","exact","screens","initialRouteName","connectedRoutes","forEach","nestedConfig","pop","RegExp","it","routeName","flatConfig","findInitialRoute","includes","createStateObject","initialRoute","isEmpty","nestedState","nestedStateIndex","parseConfig","query"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        exact?: boolean;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  let initialRoutes: InitialRouteConfig[] = [];\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(options).map((key) =>\n        createNormalizedConfigs(key, options, [], initialRoutes)\n      )\n    )\n    .sort(\n      (a, b) =>\n        // Sort configs so the most exhaustive is always first to be chosen\n        b.pattern.split('/').length - a.pattern.split('/').length\n    );\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.path === '' &&\n        config.routeNames.every(\n          // Make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.path\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        match.routeNames.map((name, i, self) => {\n          if (i === self.length - 1) {\n            return { name, params: parseQueryParams(path, match.parse) };\n          }\n\n          return { name };\n        }),\n        initialRoutes\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let allParams: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      if (!config.regex) {\n        continue;\n      }\n\n      const match = remaining.match(config.regex);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          allParams = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const value = match![(i + 1) * 2].replace(/\\//, ''); // The param segments appear every second item starting from 2 in the regex match result\n\n            acc[p] = value;\n\n            return acc;\n          }, {});\n        }\n\n        remaining = remaining.replace(match[1], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    const state = createNestedStateObject(\n      routeNames.map((name) => {\n        const config = configs.find((c) => c.screen === name);\n\n        let params: object | undefined;\n\n        if (allParams && config?.path) {\n          const pattern = config.path;\n\n          if (pattern) {\n            const paramPatterns = pattern\n              .split('/')\n              .filter((p) => p.startsWith(':'));\n\n            if (paramPatterns.length) {\n              params = paramPatterns.reduce<Record<string, any>>((acc, p) => {\n                const key = p.replace(/^:/, '').replace(/\\?$/, '');\n                const value = allParams![p];\n\n                if (value) {\n                  acc[key] =\n                    config.parse && config.parse[key]\n                      ? config.parse[key](value)\n                      : value;\n                }\n\n                return acc;\n              }, {});\n            }\n          }\n        }\n\n        if (params && Object.keys(params).length) {\n          return { name, params };\n        }\n\n        return { name };\n      }),\n      initialRoutes\n    );\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const route = findFocusedRoute(current);\n  const params = parseQueryParams(\n    path,\n    findParseConfigForRoute(route.name, configs)\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction joinPaths(...paths: string[]): string {\n  return ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n}\n\nfunction createNormalizedConfigs(\n  screen: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[],\n  parentPattern?: string\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      pattern =\n        config.exact !== true && parentPattern\n          ? joinPaths(parentPattern, config.path)\n          : config.path;\n\n      configs.push(\n        createConfigItem(screen, routeNames, pattern, config.path, config.parse)\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          connectedRoutes: Object.keys(config.screens),\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as Options,\n          routeNames,\n          initials,\n          pattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  parse?: ParseConfig\n): RouteConfig {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  const regex = pattern\n    ? new RegExp(\n        `^(${pattern\n          .split('/')\n          .map((it) => {\n            if (it.startsWith(':')) {\n              return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n            }\n\n            return `${escape(it)}\\\\/`;\n          })\n          .join('')})`\n      )\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createStateObject(\n  initialRoute: string | undefined,\n  routeName: string,\n  params: Record<string, any> | undefined,\n  isEmpty: boolean\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, { name: routeName as string, params }],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, params }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, params, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, params, state: { routes: [] } }],\n      };\n    }\n  }\n}\n\nfunction createNestedStateObject(\n  routes: { name: string; params?: object }[],\n  initialRoutes: InitialRouteConfig[]\n) {\n  let state: InitialState;\n  let route = routes.shift() as { name: string; params?: object };\n  let initialRoute = findInitialRoute(route.name, initialRoutes);\n\n  state = createStateObject(\n    initialRoute,\n    route.name,\n    route.params,\n    routes.length === 0\n  );\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as { name: string; params?: object })) {\n      initialRoute = findInitialRoute(route.name, initialRoutes);\n\n      const nestedStateIndex =\n        nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route.name,\n        route.params,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex]\n          .state as InitialState;\n      }\n    }\n  }\n\n  return state;\n}\n\nfunction findFocusedRoute(state: InitialState) {\n  let current: InitialState | undefined = state;\n\n  while (current?.routes[current.index || 0].state) {\n    // The query params apply to the deepest route\n    current = current.routes[current.index || 0].state;\n  }\n\n  const route = (current as PartialState<NavigationState>).routes[\n    current?.index || 0\n  ];\n\n  return route;\n}\n\nfunction parseQueryParams(\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) {\n  const query = path.split('?')[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}\n"]},"metadata":{},"sourceType":"module"}